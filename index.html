<!DOCTYPE html><html lang="en"><head>
    <meta charset="UTF-8"><title>Famidash Editor</title>
    <link rel="icon" type="image/png" href="icon/cube.png">
    <style>
        :root {
            --br: 15px;
        }
        @supports (corner-shape: squircle) {
            :root {
                --br: 30px;
            }
        }
        body {
            overflow: hidden;
            color: #eee;
            font-family: sans-serif;
        }
        button, select {
            background-color: #222;
            color: #eee;
        }
        @keyframes fadeOut {
            from {top: 20vh}
            to {top: -60vh; width: 20vw; left: 40vw; opacity: 0}
        }
        #splash {
            position: absolute;
            left: 25vw;
            top: 20vh;
            width: 50vw;
            z-index: 1;
            box-shadow: 0px 0px 20px #fff;
            border-radius: 10px;
            animation: fadeOut 1s ease-in .7s 1;
            animation-fill-mode: forwards;
            user-drag: none;
            -webkit-user-drag: none;
            user-select: none;
            -moz-user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
        }
        #canvas {
            position: absolute;
            left: 0px;
            top: 0px;
            width: 100vw;
            height: 100vh;
        }
        #simulatorCanvas {
            position: absolute;
            left: calc((100vw - ((100vh - 180px)/1.5 * 256/240))/2);
            top: calc((100vh - 180px)/6);
            width: calc((100vh - 180px)/1.5 * 256/240);
            height: calc((100vh - 180px)/1.5);
            border: 10px solid black;
            border-radius: 10px;
            box-shadow: 0px 0px 100vw black
        }
        #menu {
            position: absolute;
            display: flex;
            flex-direction: row;
            bottom: 20px;
            left: 2vw;
            width: 96vw;
            height: 100px;
            background-color: #111;
            border: 2px solid #aaa;
            border-radius: var(--br);
            corner-shape: squircle;
            box-shadow: 0px 4px 30px #fff5;
        }
        .menuGroup {
            display: inline-block;
            vertical-align: top;
            align-content: center;
            text-align: center;
            border: 2px solid #aaa;
            border-radius: var(--br);
            corner-shape: squircle;
            height: 80px;
            margin-left: 10px;
            margin-top: 10px;
            padding-left: 5px;
            padding-right: 5px;
        }
        .menuGroupItem {
            margin: 0px;
        }
        #tabs {
            position: absolute;
            bottom: 100px;
            left: 3vw;
            width: 90vw;
            height: 40px;
            padding: 5px;
            background-color: #333;
            border: 2px solid #aaa;
            border-radius: var(--br);
            corner-shape: squircle;
            border-bottom-left-radius: 0px;
            border-bottom-right-radius: 0px;
        }
        .tabButton {
            margin-top: 8px;
            margin-left: 8px;
        }
        .paletteButton {
            display: block;            
            flex-shrink: 0;
            height: 50px;
            width: 50px;
            box-shadow: 0px 0px 5px #fff5;
            transition: all 0.1s ease;
        }
        #tilesContainer, #spritesContainer {
            display: flex;
            align-items: center;
            overflow-x: auto;
            overflow-y: hidden;
            width: 100%;
            height: 100%;
            padding: 0 15px;
            gap: 10px;
            scrollbar-width: none;
            -ms-overflow-style: none;  
        }
        #tilesContainer::-webkit-scrollbar, 
        #spritesContainer::-webkit-scrollbar {
            display: none;
        }
    </style>
</head>
<body>
    <img src="splash.png" id="splash">
    <canvas id="canvas"></canvas>
    <canvas hidden id="parallaxCanvas" width=144 height=72></canvas>
    <canvas hidden id="groundCanvas" width=64 height=128></canvas>
    <canvas hidden id="tilesetCanvas" width=256 height=256></canvas>
    <canvas hidden id="attemptCanvas" width=119 height=8></canvas>
    <canvas id="simulatorCanvas" width=256 height=240 style="visibility: hidden"></canvas>
    <div id="menu">
        <div id="tabs">
            <button id="tilesButton" class="tabButton" style="background-color: #444">Tiles</button>
            <button id="spritesButton" class="tabButton">Sprites</button>
            <button id="settingsButton" class="tabButton">Settings</button>
            <button style="opacity: 0">e</button>
            <button id="undo" class="tabButton">↩️</button>
            <button id="redo" class="tabButton">↪️</button>
            <button style="opacity: 0">e</button>
            <button id="pen" class="tabButton" style="background-color: #444">Pen</button>
            <button id="line" class="tabButton">Line</button>
            <button id="rect" class="tabButton">Rect</button>
            <button id="fill" class="tabButton">Fill</button>
            <button id="move" class="tabButton">Move</button>
            <button id="structure" class="tabButton">Structure</button>
            <select id="structureType">
                <option value=32>A</option>
                <option value=64>B</option>
                <option value=96>C</option>
            </select>
            <button id="startPos" class="tabButton">Startpos</button>
            <button style="opacity: 0">e</button>
            <button id="simulatorButton">Simulator [BETA]</button>
        </div>
        <div id="tilesContainer"></div>
        <div id="spritesContainer" style="display: none"></div>
        <div id="settingsContainer" style="display: none">
            <div class="menuGroup">
                <p class="menuGroupItem" id="widthText">Width: 128</p>
                <input class="menuGroupItem" id="widthInput" type="range" value=128 min=128 max=2048>
                <p class="menuGroupItem" id="heightText">Height: 32</p>
                <input class="menuGroupItem" id="heightInput" type="range" value=32 min=16 max=57>
            </div>
            <div class="menuGroup">
                Blocks:<select id="blockSet">
                    <option value="a" selected>A</option>
                    <option value="b">B</option>
                    <option value="c">C</option>
                    <option value="d">D</option>
                </select>
                <p style="margin: 5px"></p>
                Spikes:<select id="spikeSet">
                    <option value="a" selected>A</option>
                    <option value="b">B</option>
                    <option value="c">C</option>
                </select>
                <p style="margin: 5px"></p>
                Slopes:<select id="slopeSet">
                    <option value="a">Yes</option>
                    <option value="none" selected>No</option>
                </select>
            </div>
            <div class="menuGroup">
                <button id="saveButton">Save TMX</button>
                <p style="margin: 5px"></p>
                <button id="loadButton">Load TMX</button>
                <p style="margin: 5px"></p>
                <button id="clearButton">Clear</button>
            </div>
            <div class="menuGroup">
                <button id="splashEnable">Splash Screen On</button>
                <button id="autosaveEnable">Autosave On</button>
                <p style="margin: 5px"></p>
                <button id="gridlineEnable">Gridlines On</button>
                <button id="attemptEnable">Attempt Counter On</button>
            </div>
            <div class="menuGroup">
                <button id="colorPreviewEnable">Color Preview On</button>
                <p style="margin: 5px"></p>
                <button id="previewEnable">Sprite Preview Off</button>
                <p style="margin: 5px"></p>
                <button id="audioUploadButton">Upload Audio</button>
            </div>
        </div>
    </div>
    <a id="fileSave" hidden></a>
    <input type="file" id="fileLoad" accept=".tmx,.xml" hidden>
    <input type="file" id="audioLoad" accept="audio/*" hidden>
    <audio id="audioPlayer" hidden></audio>
    <script>
        function sleep(t) {return new Promise(resolve => setTimeout(resolve, t));};
// SET UP VARIABLES
        const canvas = document.getElementById('canvas');
        const parallaxCanvas = document.getElementById('parallaxCanvas');
        const groundCanvas = document.getElementById('groundCanvas');
        const tilesetCanvas = document.getElementById('tilesetCanvas');
        const attemptCanvas = document.getElementById('attemptCanvas');
        const simulatorCanvas = document.getElementById('simulatorCanvas');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false;
        const parallaxCtx = parallaxCanvas.getContext('2d');
        const groundCtx = groundCanvas.getContext('2d');;
        const tilesetCtx = tilesetCanvas.getContext('2d');
        const attemptCtx = attemptCanvas.getContext('2d');
        const simulatorCtx = simulatorCanvas.getContext('2d');
        parallaxCtx.imageSmoothingEnabled = groundCtx.imageSmoothingEnabled = tilesetCtx.imageSmoothingEnabled = 
        attemptCtx.imageSmoothingEnabled = simulatorCtx.imageSmoothingEnabled = false;
        parallaxCtx.willReadFrequently = groundCtx.willReadFrequently = tilesetCtx.willReadFrequently = 
        attemptCtx.willReadFrequently = true;

        const tilesButton = document.getElementById('tilesButton');
        const spritesButton = document.getElementById('spritesButton');
        const settingsButton = document.getElementById('settingsButton');
        const tilesContainer = document.getElementById('tilesContainer');
        const spritesContainer = document.getElementById('spritesContainer');
        const settingsContainer = document.getElementById('settingsContainer');
        const penButton = document.getElementById('pen');
        const lineButton = document.getElementById('line');
        const rectButton = document.getElementById('rect')
        const fillButton = document.getElementById('fill');
        const moveButton = document.getElementById('move');
        const structureButton = document.getElementById('structure');
        const structureType = document.getElementById('structureType');
        const startPosButton = document.getElementById('startPos');
        const simulatorButton = document.getElementById('simulatorButton');
        const widthInput = document.getElementById('widthInput');
        const heightInput = document.getElementById('heightInput');
        const widthText = document.getElementById('widthText');
        const heightText = document.getElementById('heightText');
        const undoButton = document.getElementById('undo');
        const redoButton = document.getElementById('redo');
        const saveButton = document.getElementById('saveButton');
        const loadButton = document.getElementById('loadButton');
        const clearButton = document.getElementById('clearButton');
        const fileSave = document.getElementById('fileSave');
        const fileLoad = document.getElementById('fileLoad');
        const audioLoad = document.getElementById('audioLoad');
        const blockSet = document.getElementById('blockSet');
        const spikeSet = document.getElementById('spikeSet');
        const slopeSet = document.getElementById('slopeSet');
        const splashEnable = document.getElementById('splashEnable');
        const autosaveEnable = document.getElementById('autosaveEnable');
        const colorPreviewEnable = document.getElementById('colorPreviewEnable');
        const gridlineEnable = document.getElementById('gridlineEnable');
        const attemptEnable = document.getElementById('attemptEnable');
        const audioUploadButton = document.getElementById('audioUploadButton');

        const assets = ['parallax.bmp','ground.bmp','attempt.png','player.png','startpos.png'];
        const [parallaxImg,groundImg,attemptImg,playerImg,startPosImg] = assets.map(i => Object.assign(new Image(), {src: i}));
        let tileImg = new Image(); tileImg.src = `tilesets/BlocksaSpikesaSawsaSlopesa.png`;
        let spriteImg = new Image(); spriteImg.src = `sprites.png`;
        let previewSpriteImg = new Image();
        let mousepos = [0,0];
        document.addEventListener('mousemove', (e)=>{
            if (mouseState == 3) {
                camera.x += e.clientX-mousepos[0]
                camera.y += e.clientY-mousepos[1];
            }
            mousepos = [e.clientX,e.clientY];
            [drag[2],drag[3]] = mousepos;
            if (tool==0 && mouseState==1) placeBlock();
            draw();
        });
        let mouseState = 0; // 0=none, 1=left, 2=right

        let prefs = [1,1,1,1,1]; //splash screen, autosave, color preview, gridlines, attempt
        let openTab = 0;
        let tool = 0; // pen, line, rect, fill
        let settingsOpen = false;
        let camera = {x: 40, y: -1650+window.innerHeight, z: 1};
        let gridSize = [128,32];
        let selectedTile = [16,0];
        let selectionGrid = false;
        const cellSize = 400/9;
        let tileset = ['a','a','none'];
        // next two lines are AI assisted, they basically create 2D arrays with the grid size and fill them with empty cells
        let tileGrid = Array.from({length: gridSize[1]},()=>Array(gridSize[0]).fill(0));
        let spriteGrid = Array.from({length: gridSize[1]},()=>Array(gridSize[0]).fill(-1));
        if (localStorage.getItem('famidash_editor_version')!=2) {
            localStorage.setItem('famidash_editor_version',2);
            localStorage.setItem('famidash_editor_autosave',JSON.stringify([tileGrid,spriteGrid,gridSize,tileset]));
            localStorage.setItem('famidash_editor_prefs', JSON.stringify(prefs));
        }
        if (localStorage.getItem('famidash_editor_prefs')) prefs = JSON.parse(localStorage.getItem('famidash_editor_prefs'));
        if (localStorage.getItem('famidash_editor_autosave')&&prefs[1]) [tileGrid,spriteGrid,gridSize,tileset]=JSON.parse(localStorage.getItem('famidash_editor_autosave'));
        let fileHandle, autosaveTimeout;
        let history = [];
        let historyIndex = -1;
        let drag = [0,0,0,0];
        let bgColor = 146;
        let groundColor = 130;
        let objColor = 176;
        let prevColors = [0,0,0];
        let simulatorOpen = false;
        let levelAudio = false;
        let jump = false;
        let startPos = [0,0];

        const bgTriggers = [128,129,130,131,132,133,134,135,136,137,138,139,140,143,144,145,146,147,148,149,150,151,152,153,154,155,156,160,161,162,163,164,165,166,167,168,169,170,171,172];
        const bgColors = [
            [[102,102,102],[0,0,0]],
            [[13,41,131],[0,0,0]],
            [[20,18,160],[0,0,0]],
            [[53,5,157],[0,0,0]],
            [[84,12,121],[0,0,0]],
            [[100,16,63],[0,0,0]],
            [[99,19,9],[0,0,0]],
            [[79,33,8],[0,0,0]],
            [[51,53,10],[0,0,0]],
            [[32,71,15],[0,0,0]],
            [[33,81,18],[0,0,0]],
            [[31,78,22],[0,0,0]],
            [[24,63,76],[0,0,0]],
            [[0,0,0],[0,0,0]],
            [[173,173,173],[102,102,102]],
            [[45,94,209],[13,41,131]],
            [[66,64,205],[20,18,160]],
            [[108,44,244],[53,5,157]],
            [[147,40,197],[84,12,121]],
            [[168,47,120],[100,16,63]],
            [[167,60,42],[99,19,9]],
            [[143,82,27],[79,33,8]],
            [[107,109,31],[51,53,10]],
            [[78,133,37],[32,71,15]],
            [[66,145,40],[33,81,18]],
            [[62,141,62],[31,78,22]],
            [[53,122,139],[24,63,76]],
            [[255,255,255],[173,173,173]],
            [[118,174,249],[45,94,209]],
            [[146,144,248],[66,64,205]],
            [[187,122,247],[108,44,244]],
            [[226,114,248],[147,40,197]],
            [[236,119,200],[168,47,120]],
            [[238,136,118],[167,60,42]],
            [[223,161,65],[143,82,27]],
            [[188,190,60],[107,109,31]],
            [[154,214,66],[78,133,37]],
            [[131,225,82],[66,145,40]],
            [[118,221,139],[62,141,62]],
            [[112,202,219],[53,122,139]],
        ]
        const objColors = [
            [255,255,255],
            [45,94,209],
            [66,64,205],
            [108,44,244],
            [147,40,197],
            [168,47,120],
            [167,60,42],
            [223,161,65],
            [188,190,60],
            [154,214,66],
            [131,225,82],
            [118,221,139],
            [112,202,219],
            [118,174,249],
            [143,82,27],
            [0,0,0]
        ]
        const spriteFrames = [
            1,1,1,1,1,4,4,4,1,1,4,4,4,4,4,0,
            1,1,1,1,1,1,1,1,1,1,4,4,0,0,0,0,
            1,1,1,1,1,4,4,4,4,0,2,2,2,1,1,1,
            1,1,2,2,2,2,2,2,2,2,2,2,2,1,2,2,
            0,0,0,0,4,2,2,0,0,2,2,1,2,2,1,1,
            2,2,4,4,2,2,1,1,1,2,2,2,2,2,2,1,
            1,1,1,1,0,4,1,1,1,1,0,0,0,1,4,0,
            0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,
        ];
// PRELOAD IMAGES
        const imgPreload = [];
        for (let i of ['parallax.bmp','noparallax.bmp']) {
            const img = new Image();
            img.src = i;
            imgPreload.push(img);
        }
        for (let blocks of ['a','b','c','d']) {
            for (let spikes of ['a','b','c']) {
                for (let slopes of ['a','none']) {
                    const img = new Image();
                    img.src = `tilesets/Blocks${blocks}Spikes${spikes}SawsaSlopes${slopes}.png`;
                    imgPreload.push(img);
                }
            }
        }
        for (let i = 0; i < 128; i++) {
            if (spriteFrames[i]) {
                for (let j = 0; j < spriteFrames[i]; j++) {
                    const img = new Image();
                    img.src = `sprites/${i}_${j}.png`;
                    imgPreload.push(img);
                }
            }
        }

//MENU INPUT LISTENERS
        tilesButton.addEventListener('click', ()=>{tabButton(0)});
        spritesButton.addEventListener('click', ()=>{tabButton(1)});
        settingsButton.addEventListener('click', ()=>{tabButton(2)});
        function tabButton(i) {
            if (i<2) openTab = i;
            const tabButtons = [tilesButton,spritesButton,settingsButton];
            const containers = [tilesContainer,spritesContainer,settingsContainer];
            for (let i=0; i<3; i++) {
                tabButtons[i].style.backgroundColor = '#222';
                containers[i].style.display = 'none';
            }
            tabButtons[i].style.backgroundColor = '#444';
            containers[i].style.display = 'flex';
        }
        penButton.addEventListener('click', ()=>{toolButton(0)});
        lineButton.addEventListener('click', ()=>{toolButton(1)});
        rectButton.addEventListener('click', ()=>{toolButton(2)});
        fillButton.addEventListener('click', ()=>{toolButton(3)});
        moveButton.addEventListener('click', ()=>{toolButton(4)});
        structureButton.addEventListener('click', ()=>{toolButton(5)});
        startPosButton.addEventListener('click', ()=>{toolButton(6)});
        function toolButton(i) {
            tool = i
            const toolButtons = [penButton,lineButton,rectButton,fillButton,moveButton,structureButton,startPosButton];
            for (let button of toolButtons) {
                button.style.backgroundColor = '#222'
            }
            toolButtons[i].style.backgroundColor = '#444';
        }
        simulatorButton.addEventListener('click', ()=>{
            simulatorOpen = !simulatorOpen;
            simulatorCanvas.style.visibility = simulatorOpen?'visible':'hidden';
            if (simulatorOpen) simulator();
        })
        widthInput.value = gridSize[0];
        heightInput.value = gridSize[1];
        camera.y = window.innerHeight-gridSize[1]*cellSize*camera.z-250;
        widthInput.addEventListener('change', ()=>{
            gridSize[0] = widthInput.value;
            let newTileGrid = [];
            let newSpriteGrid = [];
            for (let y = 0; y < gridSize[1]; y++) {
                newTileGrid.push([]);
                newSpriteGrid.push([]);
                for (let x = 0; x < gridSize[0]; x++) {
                    newTileGrid[y].push((tileGrid[y][x])?tileGrid[y][x]:0);
                    newSpriteGrid[y].push((spriteGrid[y][x])?spriteGrid[y][x]:-1);
                }
            }
            tileGrid = newTileGrid;
            spriteGrid = newSpriteGrid;
            draw();
        });
        heightInput.addEventListener('change', ()=>{
            camera.y += (gridSize[1] - heightInput.value)*cellSize*camera.z;
            gridSize[1] = heightInput.value;
            let newTileGrid = [];
            let newSpriteGrid = [];
            for (let y = 1; y <= gridSize[1]; y++) {
                newTileGrid.unshift((tileGrid.at(-y))?tileGrid.at(-y):Array(gridSize[0]).fill(0));
                newSpriteGrid.unshift((spriteGrid.at(-y))?spriteGrid.at(-y):Array(gridSize[0]).fill(-1));
            }
            tileGrid = newTileGrid;
            spriteGrid = newSpriteGrid;
            draw();
        });
        blockSet.value = tileset[0];
        spikeSet.value = tileset[1];
        slopeSet.value = tileset[2];
        blockSet.addEventListener('change', ()=>{
            tileset[0] = blockSet.value;
            updateTilesets(tileset);
        });
        spikeSet.addEventListener('change', ()=>{
            tileset[1] = spikeSet.value;
            updateTilesets(tileset);
        });
        slopeSet.addEventListener('change', ()=>{
            tileset[2] = slopeSet.value;
            updateTilesets(tileset);
        });
        undoButton.addEventListener('click', undo);
        redoButton.addEventListener('click', redo);
        saveButton.addEventListener('click', save);
        loadButton.addEventListener('click', ()=>{fileLoad.click()});
        fileLoad.addEventListener('change', (e)=>{load(e)});
        clearButton.addEventListener('click', ()=>{
            if (window.confirm('Are you sure you want to clear all tiles and sprites?')) {
                gridSize = [128,32];
                tileGrid = Array.from({length: gridSize[1]},()=>Array(gridSize[0]).fill(0));
                spriteGrid = Array.from({length: gridSize[1]},()=>Array(gridSize[0]).fill(-1));
                bgColor = 146; groundColor = 130; objColor = 176;
                saveHistory();
            }
            fileHandle = undefined;
        });
        splashEnable.textContent = `Splash Screen ${(prefs[0]==1)?'On':'Off'}`;
        splashEnable.addEventListener('click', ()=>{
            prefs[0] = 1-prefs[0];
            localStorage.setItem('famidash_editor_prefs', JSON.stringify(prefs));
            splashEnable.textContent = `Splash Screen ${(prefs[0]==1)?'On':'Off'}`;
        });
        if (!prefs[0]) document.getElementById('splash').remove();
        autosaveEnable.textContent = `Autosave ${(prefs[1]==1)?'On':'Off'}`;
        autosaveEnable.addEventListener('click', ()=>{
            prefs[1] = 1-prefs[1];
            localStorage.setItem('famidash_editor_prefs', JSON.stringify(prefs));
            autosaveEnable.textContent = `Autosave ${(prefs[1]==1)?'On':'Off'}`;
        });
        colorPreviewEnable.textContent = `Color Preview ${(prefs[2]==1)?'On':'Off'}`;
        colorPreviewEnable.addEventListener('click', ()=>{
            prefs[2] = 1-prefs[2];
            localStorage.setItem('famidash_editor_prefs', JSON.stringify(prefs));
            colorPreviewEnable.textContent = `Color Preview ${(prefs[2]==1)?'On':'Off'}`;
        });
        gridlineEnable.textContent = `Gridlines ${(prefs[3]==1)?'On':'Off'}`;
        gridlineEnable.addEventListener('click', ()=>{
            prefs[3] = 1-prefs[3];
            localStorage.setItem('famidash_editor_prefs', JSON.stringify(prefs));
            gridlineEnable.textContent = `Gridlines ${(prefs[3]==1)?'On':'Off'}`;
        })
        attemptEnable.textContent = `Attempt Counter ${(prefs[4]==1)?'On':'Off'}`;
        attemptEnable.addEventListener('click', ()=>{
            prefs[4] = 1-prefs[4];
            localStorage.setItem('famidash_editor_prefs', JSON.stringify(prefs));
            attemptEnable.textContent = `Attempt Counter ${(prefs[4]==1)?'On':'Off'}`;
        });
        audioUploadButton.addEventListener('click', ()=>{audioLoad.click();});
        audioLoad.addEventListener('change', (e)=>{
            data = e.target.files[0];
            const reader = new FileReader();
            reader.onload = (e)=>{
                data = e.target.result;
                document.getElementById('audioPlayer').src = data;
            }
            reader.readAsDataURL(data);
        })
//CANVAS/DOCUMENT LISTENERS
        canvas.addEventListener('wheel', (e)=>{
            e.preventDefault();
            if (e.ctrlKey) {
                const prevZoom = camera.z;
                camera.z *= 2**(-Math.min(e.deltaY,30)/30);
                camera.z = Math.max(0.2, Math.min(camera.z, 8));
                camera.x += (mousepos[0] - camera.x) * (1 - (camera.z/prevZoom));
                camera.y += (mousepos[1] - camera.y) * (1 - (camera.z/prevZoom));
            } else {
                if (e.shiftKey) {
                    camera.x -= e.deltaY;
                    camera.y -= e.deltaX;
                } else {
                    camera.x -= e.deltaX;
                    camera.y -= e.deltaY;
                }
            };
            draw();
        });
        canvas.addEventListener('mousedown', (e)=>{
            [drag[0],drag[1]] = mousepos;
            if (e.button == 0) {
                mouseState = 1;
                if (tool==0 || selectionGrid) placeBlock();
                if (tool==4) {
                    let coords = dispToGrid(drag[0],drag[1]);
                    selectedTile[openTab] = (openTab?spriteGrid:tileGrid)[coords[1]][coords[0]];
                    (openTab?spriteGrid:tileGrid)[coords[1]][coords[0]] = openTab?-1:0;
                };
                if (tool==5) structure();
                if (tool==6) {
                    let [x,y] = dispToGrid(drag[0],drag[1]);
                    startPos = [x,gridSize[1]-y-1];
                }
                draw();
            };
            if (e.button == 2) {
                mouseState = 2;
                selectionGrid = false;
            };
            if (e.button == 1) {
                mouseState = 3;
            }
        });
        canvas.addEventListener('mouseup', (e)=>{
            if (mouseState==1 && tool>0 && tool<4 && !selectionGrid) {drawShape(); draw()};
            if (mouseState==1 && tool==4) {placeBlock(); draw();};
            if (mouseState==2) {
                let coords = dispToGrid(drag[0],drag[1]);
                let newCoords = dispToGrid(drag[2],drag[3])
                if (coords[0] == newCoords[0] && coords[1] == newCoords[1]) {
                    let newTile = (openTab?spriteGrid:tileGrid)[coords[1]][coords[0]];
                    selectTile(openTab?[selectedTile[0],newTile]:[newTile,selectedTile[1]]);
                } else {
                    let selectedArea = [...coords,...newCoords];
                    selectionGrid = [];
                    let [x0,y0,x1,y1] = selectedArea;
                    if (x0>x1) [x0,x1] = [x1,x0];
                    if (y0>y1) [y0,y1] = [y1,y0];
                    for (let y = y0; y <= y1; y++) {
                        selectionGrid.push([]);
                        for (let x = x0; x <= x1; x++) {
                            selectionGrid[y-y0].push((openTab?spriteGrid:tileGrid)[y][x]);
                        }
                    }
                }
            };
            mouseState = 0;
            saveHistory();
        });
        document.addEventListener('contextmenu', (e)=>{
            e.preventDefault();
        });
        document.addEventListener('keydown', (e)=>{
            if (e.key == 'z' && (e.ctrlKey||e.metaKey) && !e.shiftKey) {e.preventDefault(); undo()};
            if (e.key == 'y' && (e.ctrlKey||e.metaKey)) {e.preventDefault(); redo()};
            if (e.key == 'z' && (e.ctrlKey||e.metaKey) && e.shiftKey) {e.preventDefault(); redo()};
            if (e.key == 's' && (e.ctrlKey||e.metaKey)) {e.preventDefault(); saveButton.click()};
            if (e.key == 's' && !(e.ctrlKey||e.metaKey)) spritesButton.click();
            if (e.key == 't' && !(e.ctrlKey||e.metaKey)) tilesButton.click();
            if (e.key == 'c' && (e.ctrlKey||e.metaKey) && selectionGrid) {
                e.preventDefault();
                navigator.clipboard.writeText(JSON.stringify(selectionGrid));
            };
            if (e.key == 'v' && (e.ctrlKey||e.metaKey)) {
                e.preventDefault();
                navigator.clipboard.readText().then((pastedText)=>{selectionGrid = JSON.parse(pastedText)});
            };
            if ([' ','ArrowUp'].includes(e.key)) jump = true;
        });
        document.addEventListener('keyup', (e)=>{
            if ([' ','ArrowUp'].includes(e.key)) jump = false;
        })
        window.addEventListener('resize', ()=>{
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            ctx.imageSmoothingEnabled = false;
            draw();
        })
//MAIN
        updateTilesets();
        draw();
        saveHistory();
        setTimeout(()=>{setColor(true);draw()},1000);
        tileImg.onload = spriteImg.onload = ()=>{updateTilesets()};
//FUNCTIONS
        async function simulator() {
            function die() {
                xPos = yPos = yVel = scrollX = scrollY = gamemode = 0;
                gravity = 1;
                document.getElementById('audioPlayer').currentTime = 0;
                document.getElementById('audioPlayer').play();
            }
            function drawSim() {
                setColor();
                simulatorCtx.fillStyle = 'black';
                simulatorCtx.fillRect(0,0,256,240);
                for (let x = -mod(Math.floor(scrollX/4),144); x <= 256; x+=144) {
                    for (let y = -mod(-Math.floor(scrollY),72); y <= 240; y+= 72) {
                        simulatorCtx.drawImage(parallaxCanvas, x, y, 144, 72);
                    }
                }
                for (let x = -scrollX; x<=256; x+=64) {
                    simulatorCtx.drawImage(groundCanvas, x, 192+Math.floor(scrollY), 64, 128);
                }
                for (let x = 0; x < gridSize[0]; x++) {
                    if (x*16-scrollX<-16) continue;
                    if (x*16-scrollX>256) break;
                    for (let y = 0; y < gridSize[1]; y++) {
                        if (y*16-(gridSize[1]*16-scrollY-192)<-16) continue;
                        if (y*16-(gridSize[1]*16-scrollY-192)>240) break;
                        if (tileGrid[y][x]!=0) {
                            simulatorCtx.drawImage(
                                tilesetCanvas,
                                16*(tileGrid[y][x]%16), 
                                16*(Math.floor(tileGrid[y][x]/16)), 
                                16, 16,
                                Math.floor(x*16 - scrollX),
                                Math.floor(y*16 - (gridSize[1]*16-scrollY-192)),
                                16, 16
                            )
                        }
                        if (spriteGrid[y][x]!=-1) {
                            if (bgTriggers.includes(spriteGrid[y][x])) {
                                bgColor = spriteGrid[y][x]
                            } else if (bgTriggers.includes(spriteGrid[y][x]-64)) {
                                groundColor = spriteGrid[y][x]-64
                            } else if (spriteGrid[y][x]>=176 && spriteGrid[y][x]<192) {
                                objColor = spriteGrid[y][x]
                            } else {
                                if (spriteGrid[y][x]<128 && spriteFrames[spriteGrid[y][x]]) {
                                    previewSpriteImg.src = `sprites/${spriteGrid[y][x]}_${Math.floor((Date.now()-animationTime)/1000*spriteFrames[spriteGrid[y][x]]**2/2)%spriteFrames[spriteGrid[y][x]]}.png`;
                                    simulatorCtx.drawImage(
                                        previewSpriteImg,
                                        Math.floor(x*16 - scrollX),
                                        Math.floor(y*16 - (gridSize[1]*16-scrollY-192)),
                                    )
                                } else {
                                    simulatorCtx.drawImage(
                                        spriteImg,
                                        16*(spriteGrid[y][x]%16), 
                                        16*(Math.floor(spriteGrid[y][x]/16)), 
                                        16, 16,
                                        Math.floor(x*16 - scrollX),
                                        Math.floor(y*16 - (gridSize[1]*16-scrollY-192)),
                                        16, 16
                                    )
                                }
                            }
                            if ([109,20,21,22,32,33].includes(spriteGrid[y][x]) && Math.abs(x-xPos/16)<1) {
                                speed = [1.4296875,2.2328,2.77,3.443,4.159,5.12][[109,20,21,22,32,33].indexOf(spriteGrid[y][x])]
                            }
                            if ([0,1,2,3,4,23,36,75].includes(spriteGrid[y][x]) && Math.abs(x-xPos/16)<1) {
                                gamemode = [0,1,2,3,4,23,36,75].indexOf(parseInt([spriteGrid[y][x]]));
                                widthText.textContent = Math.abs(gridSize[1]-y-1-yPos/16)<=2;
                            }
                        }
                    }
                }
                simulatorCtx.drawImage(attemptCanvas, 48-scrollX, 120+scrollY, 119, 8);
                simulatorCtx.save();
                simulatorCtx.translate(xPos-scrollX + 8, 176-yPos+scrollY + 8);
                switch (gamemode) {
                    case 0: simulatorCtx.rotate(-yVel*.1*3.1415926*gravity); break;
                    case 1: simulatorCtx.rotate(-yVel*.07*3.1415926*gravity); break;
                    case 2: ; break;
                };
                playerImg.src = 'icon/'+['cube.png','ship.png',`ball_${Math.floor((Date.now()-animationTime)/(100/3))%2}.png`,'ufo.png','robot.png','spider.png','wave.png','swing.png'][gamemode];
                simulatorCtx.drawImage(playerImg,-8,-8,16,16);
                simulatorCtx.restore();
            }
            const collisionTypes = [
                0,1,1,3,0,1,1,0,0,0,0,0,0,0,0,0, // 0 = blank   | 1 = block
                1,0,0,0,0,1,1,0,0,2,0,0,0,0,0,0, // 2 = topSlab | 3 = bottomSlab
                1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
                1,1,1,1,0,0,0,0,1,1,1,0,1,1,1,1,
                1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
                1,1,1,1,2,2,2,2,3,3,3,0,0,0,0,0,
                1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
                1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,0,
                0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                0,0,0,0,2,3,0,0,0,0,0,0,0,0,0,0,
                0,0,0,0,0,0,0,0,0,2,3,0,0,0,0,0,
                0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,
                0,2,2,0,2,0,3,2,0,0,0,0,0,0,0,0,
                0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,
            ]
            draw();
            ctx.fillStyle = '#0008';
            ctx.fillRect(0,0,canvas.width,canvas.height);
            let playerOffset = 80;
            let speed = 2.8;
            let xPos = startPos[0]*16;
            let yPos = startPos[1]*16;
            let yVel = 0;
            let scrollX = 0;
            let scrollY = 0;
            let gamemode = 0;
            let gravity = 1;
            let deltaTime = Date.now();
            let animationTime = Date.now();
            let sides, falling;
            let debt = 0;
            document.getElementById('audioPlayer').currentTime = 0;
            document.getElementById('audioPlayer').play();
            setColor(true);
            while (simulatorOpen) {
                if (debt < 1000/60) drawSim();
                xPos+=speed;
                scrollX = Math.max(0,xPos-playerOffset);
                debt += Date.now()-deltaTime;
                if (debt < 1000/60) {await sleep(1000/60 - debt)};
                debt -= Math.min(debt,1000/60);
                deltaTime = Date.now();
                sides = {
                    bottom: [Math.round(xPos/16),Math.min(gridSize[1]-Math.floor((yPos-1)/16)-1,gridSize[1]-1)],
                    front: [Math.ceil(xPos/16),Math.min(gridSize[1]-Math.round(yPos/16)-1,gridSize[1]-1)],
                    top: [Math.round(xPos/16),Math.min(gridSize[1]-Math.ceil((yPos)/16)-1,gridSize[1]-1)],
                };
                if (sides.bottom[1]<0) {die()}
                sides = {
                    bottom: tileGrid[Math.max(0,sides.bottom[1])][sides.bottom[0]],
                    front: tileGrid[Math.max(0,sides.front[1])][sides.front[0]],
                    top: tileGrid[Math.max(0,sides.top[1])][sides.top[0]]
                }; // the tile ID at the collision point of the player
                if (yPos<=0) {yPos = 0; yVel = Math.max(0,yVel)};
                function land(yOffset=0) {
                    falling = false;
                    yVel = 0;
                    yPos = Math.round(yPos/16)*16-yOffset*gravity;
                    if (jump) {
                        if (gamemode==0) {yVel = 4.7}
                        if (gamemode==2) {gravity = -gravity; yVel = -0.35}
                    };
                }
                falling = true;
                if (yPos<=0 && gravity==1) {land()};
                if (jump && gamemode==3) {yVel = 4};
                if ((collisionTypes[sides.bottom] == 1)&&(yPos%16==0||yPos%16>8)) { 
                    if (gravity==1) {land()} else {
                        yVel = 0; yPos = Math.round(yPos/16)*16
                    }
                }
                if ((collisionTypes[sides.front] == 1)) { die() }
                if ((collisionTypes[sides.top] == 1)) {
                    if (gravity==1) {
                        yVel = 0; yPos = Math.round(yPos/16)*16
                    } else {land()}
                }
                if ((collisionTypes[sides.bottom] == 2)&&(yPos%16==0||yPos%16>10)) { 
                    if (gravity==1) {land()} else {
                        yVel = 0; yPos = Math.round(yPos/16)*16+8
                    } 
                }
                //if ((collisionTypes[sides.front] == 2)) { die() }
                if ((collisionTypes[sides.top] == 2)&&(yPos%16>8&&yPos%16<=12)) {
                    if (gravity==1) {
                        yVel = 0; yPos = Math.round(yPos/16)*16-8
                    } else {land(7)}
                }
                //console.log(`${yPos%16}`)
                if ((collisionTypes[sides.bottom] == 3)&&(yPos%16<=8)) {
                    
                    if (gravity==1) {land(-7.9/*basically 8*/)} else {
                        yVel = 0; yPos = Math.round(yPos/16)*16+8
                    } 
                }
                //if ((collisionTypes[sides.front] == 3)) { die() }
                if ((collisionTypes[sides.top] == 3)&&(yPos%16<8)) {
                    if (gravity==1) {
                        yVel = 0; yPos = Math.round(yPos/16)*16-8
                    } else {land()}
                }

                if (falling && !(gamemode==1) && !(gamemode==3)) {yVel -= .37};
                if (falling && gamemode==3) {yVel -= .3}
                if (gamemode==1) {
                    if (jump) {yVel += .2} else if (falling) {yVel -= .2};
                    yVel = Math.max(-3,Math.min(yVel,3))
                }
                if (gamemode==0 || gamemode==2) {yVel = Math.max(-7,Math.min(yVel,7))}
                if (gamemode==3) {yVel = Math.max(-4,Math.min(yVel,4))}
                yPos += yVel*gravity;
                yPos = Math.max(yPos,0)
                if (yPos-scrollY>120) scrollY += yPos-scrollY-120;
                if (yPos-scrollY<0) scrollY += yPos-scrollY;
                if (scrollY>gridSize[1]*16-192) scrollY = gridSize[1]*16-192;
            }
            document.getElementById('audioPlayer').pause();
            draw();
        }

        function draw() {
            if (simulatorOpen) return;
            if (!prefs[2]) {bgColor = 146; groundColor = 130; objColor = 176};
            setColor();
            widthText.textContent = `Width: ${widthInput.value}`;
            heightText.textContent = `Height: ${heightInput.value}`;
            ctx.clearRect(0,0,canvas.width,canvas.height);
            for (let x = -mod(-camera.x/4,(camera.z*400)); x <= canvas.width; x+=camera.z*400) {
                for (let y = -mod(-camera.y,(camera.z*200)); y <= canvas.height; y+= camera.z*200) {
                    ctx.drawImage(parallaxCanvas, Math.floor(x), Math.floor(y), Math.ceil(camera.z*400), Math.ceil(camera.z*200));
                }
            }
            for (let x = Math.max(-mod(-camera.x,(camera.z*4*cellSize)),camera.x); x<=Math.min(canvas.width,camera.x+cellSize*(gridSize[0]-.5)*camera.z); x+=camera.z*4*cellSize) {
                ctx.drawImage(groundCanvas, Math.floor(x), camera.y+cellSize*gridSize[1]*camera.z, camera.z*4*cellSize, camera.z*8*cellSize);
            }
            if (prefs[3]) {
                ctx.strokeStyle = '#eee';
                ctx.lineWidth = 2;
                ctx.strokeRect(camera.x,camera.y,cellSize*gridSize[0]*camera.z,cellSize*gridSize[1]*camera.z);
                ctx.strokeStyle = '#eee8'
                ctx.lineWidth = 1;
                for (let i = 1; i < gridSize[0]; i++) {
                    ctx.beginPath();
                    ctx.moveTo(camera.x+i*cellSize*camera.z,camera.y);
                    ctx.lineTo(camera.x+i*cellSize*camera.z,camera.y+gridSize[1]*cellSize*camera.z);
                    ctx.stroke();
                    if (camera.x+i*cellSize*camera.z>canvas.width) break;
                }
                for (let i = 1; i < gridSize[1]; i++) {
                    ctx.beginPath();
                    ctx.moveTo(camera.x,camera.y+i*cellSize*camera.z);
                    ctx.lineTo(camera.x+gridSize[0]*cellSize*camera.z,camera.y+i*cellSize*camera.z);
                    ctx.stroke();
                    if (camera.y+i*cellSize*camera.z>canvas.height) break;
                } 
            }
            for (let x = 0; x < gridSize[0]; x++) {
                if (camera.x+x*cellSize*camera.z<-cellSize*camera.z) continue;
                if (camera.x+x*cellSize*camera.z>canvas.width) break;
                for (let y = 0; y < gridSize[1]; y++) {
                    if (camera.y+y*cellSize*camera.z<-cellSize*camera.z) continue;
                    if (camera.y+y*cellSize*camera.z>canvas.height) break;
                    if (tileGrid[y][x]!=-1) {
                        ctx.drawImage(
                            tilesetCanvas,
                            16*(tileGrid[y][x]%16), 
                            16*(Math.floor(tileGrid[y][x]/16)), 
                            16, 16,
                            x*cellSize*camera.z + camera.x,
                            y*cellSize*camera.z + camera.y,
                            cellSize*camera.z, cellSize*camera.z
                        )
                    }
                    if (spriteGrid[y][x]!=-1) {
                        if (bgTriggers.includes(spriteGrid[y][x])) {
                            bgColor = spriteGrid[y][x]
                        }
                        if (bgTriggers.includes(spriteGrid[y][x]-64)) {
                            groundColor = spriteGrid[y][x]-64
                        }
                        if (spriteGrid[y][x]>=176 && spriteGrid[y][x]<192) {
                            objColor = spriteGrid[y][x]
                        }
                        ctx.drawImage(
                            spriteImg,
                            16*(spriteGrid[y][x]%16), 
                            16*(Math.floor(spriteGrid[y][x]/16)), 
                            16, 16,
                            x*cellSize*camera.z + camera.x,
                            y*cellSize*camera.z + camera.y,
                            cellSize*camera.z, cellSize*camera.z
                        )
                    }
                    if (tool==6 && JSON.stringify(startPos) == JSON.stringify([x,gridSize[1]-y-1])) {
                        ctx.drawImage(
                            startPosImg, 0, 0, 16, 16,
                            x*cellSize*camera.z + camera.x,
                            y*cellSize*camera.z + camera.y,
                            cellSize*camera.z, cellSize*camera.z
                        )
                    }
                }
            }
            if (prefs[4]) {
                ctx.drawImage(attemptCanvas, camera.x+3*cellSize*camera.z, camera.y+(gridSize[1]-4.5)*cellSize*camera.z, 7.4375*cellSize*camera.z, .5*cellSize*camera.z);
            }
            ctx.globalAlpha = 0.5;
            if (!selectionGrid && !(tool==4 && mouseState!=1) && tool!=5 && tool!=6) {
                ctx.drawImage(
                    openTab?spriteImg:tileImg,
                    16*(selectedTile[openTab]%16),
                    16*(Math.floor(selectedTile[openTab]/16)), 
                    16, 16,
                    (Math.floor((mousepos[0]-camera.x)/camera.z/cellSize)*cellSize*camera.z)+camera.x,
                    (Math.floor((mousepos[1]-camera.y)/camera.z/cellSize)*cellSize*camera.z)+camera.y,
                    cellSize*camera.z, cellSize*camera.z
                );
            } else if (tool==6) {
                ctx.drawImage(
                    startPosImg, 0, 0, 16, 16,
                    (Math.floor((mousepos[0]-camera.x)/camera.z/cellSize)*cellSize*camera.z)+camera.x,
                    (Math.floor((mousepos[1]-camera.y)/camera.z/cellSize)*cellSize*camera.z)+camera.y,
                    cellSize*camera.z, cellSize*camera.z
                );
            } else{
                for (let y = 0; y < selectionGrid.length; y++) {
                    for (let x = 0; x < selectionGrid[y].length; x++) {
                        if (selectionGrid[y][x]) {
                            ctx.drawImage(
                                openTab?spriteImg:tileImg,
                                16*(selectionGrid[y][x]%16), 
                                16*(Math.floor(selectionGrid[y][x]/16)), 
                                16, 16,
                                (Math.floor((mousepos[0]-camera.x)/camera.z/cellSize)+x)*cellSize*camera.z+camera.x,
                                (Math.floor((mousepos[1]-camera.y)/camera.z/cellSize)+y)*cellSize*camera.z+camera.y,
                                cellSize*camera.z, cellSize*camera.z
                            );
                        }
                    }
                }
            };
            ctx.globalAlpha = 1;
            if ((mouseState==1) && (tool>0)&&(tool<4)) {
                drawShape(true)
            };
        };

        function drawShape(preview=false) { // The line drawing algorithm is AI assisted
            function place(x,y) {
                if (preview) {
                    widthText.textContent = `${x},${y}`
                    ctx.drawImage(
                        openTab?spriteImg:tileImg,
                        16*(selectedTile[openTab]%16), 
                        16*(Math.floor(selectedTile[openTab]/16)), 
                        16, 16,
                        x*cellSize*camera.z+camera.x,
                        y*cellSize*camera.z+camera.y,
                        cellSize*camera.z, cellSize*camera.z
                    );
                } else { placeBlock([x,y]) }
            }
            function bucketFill(x,y,target) {
                if (x<0 || x>=gridSize[0] || y<0 || y>=gridSize[1]) return;
                if ((openTab?spriteGrid:tileGrid)[y][x]!=target || (openTab?spriteGrid:tileGrid)[y][x]==selectedTile[openTab]) return;
                placeBlock([x,y]);
                bucketFill(x+1,y,target);
                bucketFill(x,y+1,target);
                bucketFill(x-1,y,target);
                bucketFill(x,y-1,target);
            }
            let [x0,y0] = dispToGrid(drag[0],drag[1]);
            let [x1,y1] = dispToGrid(drag[2],drag[3]);
            let dx = x1-x0;
            let dy = y1-y0;
            let sx = Math.sign(dx);
            let sy = Math.sign(dy);
            if (tool==1) { //draw line
                dx = Math.abs(dx);
                dy = Math.abs(dy);
                let err;
                if (dx>dy) {
                    err = dx/2;
                    while (x0!=x1) {
                        place(x0,y0);
                        err -= dy;
                        if (err<0) {
                            y0 += sy;
                            err += dx;
                        }
                        x0 += sx;
                    }
                } else {
                    err = dy/2;
                    while (y0!=y1) {
                        place(x0,y0);
                        err -= dx;
                        if (err<0) {
                            x0 += sx;
                            err += dy;
                        }
                        y0 += sy;
                    }
                }
                place(x1,y1)
            }
            if (tool==2) { //draw rectangle
                if (x0>x1) [x0,x1] = [x1,x0];
                if (y0>y1) [y0,y1] = [y1,y0];
                for (let x = x0; x < x1; x++) {place(x,y0)}
                for (let y = y0; y < y1; y++) {place(x1,y)}
                for (let x = x1; x > x0; x--) {place(x,y1)}
                for (let y = y1; y > y0; y--) {place(x0,y)}
            }
            if (tool==3) { //fill
                bucketFill(x0,y0,(openTab?spriteGrid:tileGrid)[y0][x0])
            }
        };

        function structure(x=false,y=false,target=false) {
            let structureIdx = parseInt(structureType.value);
            if (x===false) {
                [x,y] = dispToGrid(drag[0],drag[1]);
                target = tileGrid[y][x];
            };
            if (x<0 || x>=gridSize[0] || y<0 || y>=gridSize[1]) return;
            if (tileGrid[y][x]!=target || (tileGrid[y][x]>=structureIdx && tileGrid[y][x]<structureIdx+20)) return;
            let surroundings = [
                (y<=0)?0:tileGrid[y-1][x],
                (x<=0)?0:tileGrid[y][x-1],
                (x+1>=gridSize[0])?0:tileGrid[y][x+1],
                (y+1>=gridSize[1])?0:tileGrid[y+1][x]
            ].map((x)=>(x==target||(x>=structureIdx&&x<structureIdx+20))?1:0);
            let combinations = [
                '[0,0,0,0]',
                '[0,1,1,1]','[1,1,0,1]','[1,1,1,0]','[1,0,1,1]',
                '[0,0,1,1]','[0,1,0,1]','[1,1,0,0]','[1,0,1,0]',
                false,false,false,false,
                '[1,0,0,1]','[0,1,1,0]',
                '[1,1,1,1]',
                '[0,0,0,1]','[0,1,0,0]','[1,0,0,0]','[0,0,1,0]'
            ];
            placeBlock([x,y],structureIdx+combinations.indexOf(JSON.stringify(surroundings)));
            structure(x+1,y,target);
            structure(x,y+1,target);
            structure(x-1,y,target);
            structure(x,y-1,target);
        };

        function setColor(forceUpdate=false) {
            if (JSON.stringify(prevColors) == JSON.stringify([bgColor,groundColor,objColor]) && !forceUpdate) return; // i hate javascript list comparisons
            function applyMap(data,tilesetMap=false) {
                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    let key = `${r},${g},${b}`;
                    if (tilesetMap) {
                        if (i<16384&&(i%1024>=64&&i%1024<192||i%1024>=320&&i%1024<448) || i>131072&&i<147456&&i%1024>=512&&i%1024<640) {
                            key = `${r},${g},${b}*`;
                        }
                    }
                    if (map[key]) {
                        const [nr, ng, nb] = map[key];
                        data[i]     = nr;
                        data[i + 1] = ng;
                        data[i + 2] = nb;
                        data[i + 3] = 255;
                    }
                }
                return data;
            };
            parallaxCtx.clearRect(0,0,144,72);
            groundCtx.clearRect(0,0,64,128);
            tilesetCtx.clearRect(0,0,256,256);
            attemptCtx.clearRect(0,0,119,8);
            parallaxImg.src = `${tileset[2]=='a'?'no':''}parallax.bmp`;
            parallaxCtx.drawImage(parallaxImg,0,0);
            groundCtx.drawImage(groundImg,0,0);
            tilesetCtx.drawImage(tileImg,0,0);
            attemptCtx.drawImage(attemptImg,0,0);
            let map, imageData, data;
            map = {
                '0,0,0':bgColors[bgTriggers.indexOf(bgColor)][0],
                '0,0,128':bgColors[bgTriggers.indexOf(bgColor)][1],
            };
            imageData = parallaxCtx.getImageData(0,0,144,72);
            imageData.data = applyMap(imageData.data);
            parallaxCtx.putImageData(imageData, 0, 0);

            map = {
                '0,0,255':bgColors[bgTriggers.indexOf(groundColor)][0],
                '0,31,157':bgColors[bgTriggers.indexOf(groundColor)][1],
                '255,255,255':objColors[objColor-176],
            };
            imageData = groundCtx.getImageData(0,0,64,128);
            imageData.data = applyMap(imageData.data);
            groundCtx.putImageData(imageData, 0, 0);

            map = {
                '0,66,198':bgColors[bgTriggers.indexOf(bgColor)][0],
                '0,16,132':bgColors[bgTriggers.indexOf(bgColor)][1],
                '0,66,198*':bgColors[bgTriggers.indexOf(groundColor)][0],
                '0,16,132*':bgColors[bgTriggers.indexOf(groundColor)][1],
                '239,239,239':objColors[objColor-176],
                '239,239,239*':objColors[objColor-176],
            };
            imageData = tilesetCtx.getImageData(0,0,256,256);
            imageData.data = applyMap(imageData.data,true);
            tilesetCtx.putImageData(imageData, 0, 0);

            map = {
                '20,18,167':bgColors[bgTriggers.indexOf(bgColor)][0],
                '66,64,255':bgColors[bgTriggers.indexOf(bgColor)][1],
                '255,254,255':objColors[objColor-176],
            }
            imageData = attemptCtx.getImageData(0,0,119,8);
            imageData.data = applyMap(imageData.data);
            attemptCtx.putImageData(imageData, 0, 0);
            prevColors = [bgColor,groundColor,objColor];
        };

        function updateTilesets() {
            tileImg.src = `tilesets/Blocks${tileset[0]}Spikes${tileset[1]}SawsaSlopes${tileset[2]}.png`;
            tilesContainer.innerHTML = '';
            spritesContainer.innerHTML = '';
            tileImg.onload = () => {
                for (i = 0; i <= 1; i++) { // i is whether it's making a tile or sprite button
                    for (y = 0; y < 16; y++) {
                        for (x = (i&&!y)?-1:0; x < 16; x++) { //start one earlier if making sprites
                            let btn = document.createElement('canvas');
                            btn.classList.add('paletteButton');
                            btn.id = `${!i?'T':'S'}${y*16+x}` // T if it's a tile, S if it's a sprite
                            btn.idx = y*16+x;
                            btn.width = 16;
                            btn.height = 16;
                            let btnctx = btn.getContext('2d');
                            btnctx.imageSmoothingEnabled = false;
                            btnctx.shadowColor = "#FFF5";
                            btnctx.shadowBlur = 7;
                            btnctx.drawImage((i==0)?tileImg:spriteImg,-x*16,-y*16,256,256);
                            if (!i) {btn.addEventListener('click', (e)=>{selectTile([e.srcElement.idx,selectedTile[1]]);selectionGrid=false})}
                            else {btn.addEventListener('click', (e)=>{selectTile([selectedTile[0],e.srcElement.idx]);selectionGrid=false})}
                            (!i?tilesContainer:spritesContainer).appendChild(btn)
                        }
                    }
                }
                selectTile(selectedTile);
                setColor(true);
            }
        };

        function selectTile(tiles) {
            const [prevX, prevY] = selectedTile;
            selectedTile = tiles;
            const [x, y] = selectedTile;
            const prevTile = document.getElementById(`T${prevX}`);
            const prevSprite = document.getElementById(`S${prevY}`);
            const tile = document.getElementById(`T${x}`);
            const sprite = document.getElementById(`S${y}`);
            prevTile.style.boxShadow = prevSprite.style.boxShadow = '';
            prevTile.style.width = prevTile.style.height = prevSprite.style.width = prevSprite.style.height = '50px';
            tile.style.boxShadow = sprite.style.boxShadow = '0px 0px 12px #2ef';
            tile.style.width = tile.style.height = sprite.style.width = sprite.style.height = '60px';
        };

        function placeBlock(pos=false,tile=selectedTile[openTab]) {
            if (selectionGrid) {
                for (let y = 0; y < selectionGrid.length; y++) {
                    for (let x = 0; x < selectionGrid[y].length; x++) {
                        let pos = dispToGrid(mousepos[0],mousepos[1]);
                        if (pos[0]+x < 0 || pos[1]+y < 0 || pos[0]+x >= gridSize[0] || pos[1]+y >= gridSize[1]) continue;
                        (openTab?spriteGrid:tileGrid)[pos[1]+y][pos[0]+x] = selectionGrid[y][x]
                    }
                }
            } else {
                let [x,y] = dispToGrid(mousepos[0],mousepos[1]);
                if (pos) [x,y] = pos;
                if (x < 0 || y < 0 || x >= gridSize[0] || y >= gridSize[1]) return;
                (openTab?spriteGrid:tileGrid)[y][x] = tile;
            }
        };

        function saveHistory() {
            if (historyIndex < history.length-1) history = history.slice(0, historyIndex + 1);
            history.push(structuredClone([tileGrid,spriteGrid,gridSize]));
            historyIndex++;
            localStorage.setItem('famidash_editor_autosave',JSON.stringify([tileGrid,spriteGrid,gridSize,tileset]));
            if (fileHandle) {
                clearTimeout(autosaveTimeout);
                autosaveTimeout = setTimeout(()=>{save()},1000);
            }
        };

        async function save() {
            let tileData = '';
            let spriteData = '';
            for (let y = 0; y < gridSize[1]; y++) {
                tileData = `${tileData}\n${tileGrid[y].map((x)=>x+1).join(',')},`;
                spriteData = `${spriteData}\n${spriteGrid[y].map((x)=>(x==-1)?0:x+257).join(',')},`;
            }
            let output = `<?xml version="1.0" encoding="UTF-8"?>
<map version="1.10" tiledversion="1.11.2" orientation="orthogonal" renderorder="right-down" width="${gridSize[0]}" height="${gridSize[1]}" tilewidth="16" tileheight="16" infinite="0" nextlayerid="5" nextobjectid="1">
 <editorsettings>
  <chunksize width="16" height="27"/>
  <export target="stereomadness.csv" format="csv"/>
 </editorsettings>
 <tileset firstgid="1" name="famidash" tilewidth="16" tileheight="16" tilecount="256" columns="16">
  <image source="../../../GRAPHICS/famidash.bmp" width="256" height="256"/>
 </tileset>
 <tileset firstgid="257" name="sprites" tilewidth="16" tileheight="16" tilecount="256" columns="16">
  <image source="../../../GRAPHICS/sprites.png" width="256" height="256"/>
 </tileset>
 <imagelayer id="3" name="Image Layer 1" parallaxx="0.9" parallaxy="0.9" repeatx="1" repeaty="1">
  <image source="../../../GRAPHICS/Old/parallax Blue.bmp" width="192" height="72"/>
 </imagelayer>
 <imagelayer id="4" name="Image Layer 2" offsetx="0" offsety="${gridSize[1]*16}" repeatx="1">
  <image source="../../../GRAPHICS/ground.bmp" width="80" height="32"/>
 </imagelayer>
 <layer id="1" width="${gridSize[0]}" height="${gridSize[1]}">
  <data encoding="csv">
${tileData.slice(1,-1)}
</data>
 </layer>
 <layer id="2" name="SP" width="${gridSize[0]}" height="${gridSize[1]}">
<data encoding="csv">
${spriteData.slice(1,-1)}
</data>
 </layer>
</map>`;
            if (!fileHandle) {
                fileHandle = await window.showSaveFilePicker({
                    suggestedName: "level.tmx",
                    types: [
                    {
                        description: "TMX File - Famidash Level Map",
                        accept: { "text/xml": [".tmx"] }
                    }
                    ]
                })
            }
            const writable = await fileHandle.createWritable();
            await writable.write(output);
            await writable.close();
        };

        function load(data) {
            data = data.target.files[0];
            const reader = new FileReader();
            reader.onload = (e)=>{
                data = e.target.result;
                gridSize = [data.split('width="')[1].split('"')[0], data.split('height="')[1].split('"')[0]];
                [widthInput.value, heightInput.value] = gridSize;
                widthText.textContent = `Width: ${widthInput.value}`;
                heightText.textContent = `Height: ${heightInput.value}`;
                let tileData = data.split('<data encoding="csv">\n')[1].split('\n</data>')[0].split('\n');
                let spriteData = data.split('<data encoding="csv">\n')[2].split('\n</data>')[0].split('\n');
                tileGrid = tileData.map((x)=>x.split(',').map((x)=>Math.max(x-1,0)).slice(0,gridSize[0]));
                spriteGrid = spriteData.map((x)=>x.split(',').map((x)=>(x==0)?-1:x-257).slice(0,gridSize[0]));
                saveHistory();
            }
            reader.readAsText(data);
        };

        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                [tileGrid, spriteGrid, gridSize] = structuredClone(history[historyIndex]);
                [widthInput.value, heightInput.value] = gridSize;
                draw();
                localStorage.setItem('famidash_editor_autosave',JSON.stringify([tileGrid,spriteGrid,gridSize,tileset]));
            }
        };

        function redo() {
            if (historyIndex < history.length-1) {
                historyIndex++;
                [tileGrid, spriteGrid, gridSize] = structuredClone(history[historyIndex]);
                [widthInput.value, heightInput.value] = gridSize;
                draw();
                localStorage.setItem('famidash_editor_autosave',JSON.stringify([tileGrid,spriteGrid,gridSize,tileset]));
            }
        };

        function mod(a,b) { return ((a%b)+b)%b };

        function dispToGrid(x,y) {
            return [Math.floor((x-camera.x)/camera.z/cellSize),Math.floor((y-camera.y)/camera.z/cellSize)]
        };
    </script>
</body></html>